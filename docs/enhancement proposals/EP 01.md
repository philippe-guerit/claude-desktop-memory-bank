# Memory Bank Improvement Proposal

## 1. Background and Motivation

The current Memory Bank implementation places excessive cognitive and technical burden on client applications:

Requires clients to understand bank types and repository details
Forces clients to make complex decisions about content organization
Creates a high integration barrier for new client implementations
Maintains unnecessary complexity with tools like "swap"

These issues stem from an architecture that distributes intelligence between client and server in a suboptimal way. Moving to a server-directed approach simplifies client integration while enabling more sophisticated memory management.

## 2. Proposed Changes

### 2.1 Simplified Client Interface

**Activate Tool Simplification:**
- Client only specifies:
  - "global" (no additional parameters) OR
  - "project" + project_name
- Server internally determines if project is code-based
- No code-specific client parameters needed
- Same project_name can be reused (client doesn't need to track uniqueness)

**Update Tool Simplification:**
- Client provides conversation updates without specifying detailed parameters
- Server determines appropriate storage location and operation
- Removes need for clients to understand bank structure

**Removal of Swap Tool:**
- Eliminate tool completely
- Enforce one conversation = one memory bank model (Each conversation has a single, consistent memory bank association from start to finish)
- Handle correction cases through reactivation

### 2.2 Server-Directed Memory Management

**Intelligence Shift:**
- Move decision-making from client to server
- Server analyzes conversation content to determine:
  - Appropriate file targets
  - Storage operations (append/replace/insert)
  - Content categorization

**Content Analysis:**
- Automatically detect architecture decisions, design patterns, etc.
- Route information to appropriate files based on content type
- Track conversation topics for better organization

**Automatic Project Type Detection:**
- Detect code repositories without explicit client parameters
- Apply appropriate project templates (code or non-code) based on detected project type

### 2.3 Standardized Non-Code Project Template

Use a single, standardized project template for all non-code project:

```
projects/{project-id}/
├── readme.md                # Project overview
├── doc/                     # Documentation directory
│   ├── objectives.md        # Goals and objectives
│   ├── decisions.md         # Key decisions (generic)
│   ├── progress.md          # Status updates
│   └── references.md        # Important references
├── notes/                   # Project-specific notes
│   ├── meeting_notes.md     # Meeting summaries
│   ├── ideas.md             # Brainstorming and ideas
│   └── research.md          # Research findings
└── cache.json               # Optimized representation
```

This single template will serve most project needs while keeping implementation simple.

## 3. Components Impacted

### 3.1 Server Implementation

**StorageManager:**
- Add project type detection logic
- Implement enhanced bank resolution without explicit bank_id
- Update standard project template implementation

**MemoryBankServer:**
- Modify tool registration to support simplified interfaces
- Add conversation analysis capabilities
- Implement automatic content categorization

**Content Router:**
- New component to analyze content and determine appropriate storage
- Uses pattern recognition to categorize conversation elements
- Maps categories to specific files and operations

### 3.2 Tool Implementations

**Activate Tool:**
```python
@server.tool(
    name="activate",
    description="Activates memory for the current conversation"
)
async def activate(
    conversation_type: str,  # "global" or "project"
    project_name: Optional[str] = None,  # Required for project
    current_path: Optional[str] = None   # Optional path hint
) -> Dict[str, Any]:
    # Implementation
```

**Update Tool:**
```python
@server.tool(
    name="update",
    description="Updates memory with conversation content"
)
async def update(
    content: str,  # The conversation content to store
    conversation_id: Optional[str] = None,
    update_count: Optional[int] = None
) -> Dict[str, Any]:
    # Implementation with content analysis
```

### 3.3 Storage Structure

**Bank Hierarchy:**
- Maintain existing global/projects/code structure
- Implement standardized project template
- Update initialization logic for projects

**Cache System:**
- Enhance optimization for standard project structure
- Improve content analysis for better categorization
- Add basic metadata for project tracking

## 4. Implementation Plan

### Phase 1: Simplified Activate Interface
1. Change activate tool to use the simplified parameters
2. Implement basic project type detection
3. Update tests to verify simplified interface

### Phase 2: Enhanced Update Tool
1. Create content analysis module for categorizing information
2. Implement content router for determining storage targets
3. Change the update tool to use the simplified parameters
3. The update tool will use the content analysis

### Phase 3: Standardized Project Template
1. Implement the standardized project template
2. Update bank initialization to use the template
3. Create tests for project template functionality

### Phase 4: Client Integration Examples
1. Create reference implementation showing simplified client usage
2. Update documentation with new approach
3. Migrate existing tests 

## Status
Completed

Possible status values:

Under Review: Proposal is being evaluated by the team
Approved: Proposal has been accepted and is ready for implementation
Under Development: Implementation is in progress
Completed: Implementation is finished and deployed